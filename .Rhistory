centers = n_nodes,
algorithm = "Lloyd",
iter.max = 1 ,nstart=10
)
kmeans_centers <- kmeans_result$centers
kmeans_labels <-  kmeans_result$cluster
kmeans_size <-  kmeans_result$size
# Similarity computation
affinity <- matrix(0, n_nodes, n_nodes)
X.centered <-
do.call(rbind, lapply(1:n, function(i) {
X[i, ] - kmeans_centers[kmeans_labels[i], ]
}))
affinity <- outer(1:n_nodes, 1:n_nodes,
Vectorize(function(k, l) {
ifelse(k == l,
0,
(sum(pmax(
0, (kmeans_centers[l,] - kmeans_centers[k, ]) %*% t(X.centered[(kmeans_labels ==
k), ])
)) +
sum(pmax(
0, (kmeans_centers[k,] - kmeans_centers[l, ]) %*% t(X.centered[(kmeans_labels ==
l), ])
))) /
(sum((kmeans_centers[k,] - kmeans_centers[l, ]) ^
2
) * (kmeans_size[k] + kmeans_size[l])))
}))
#affinity <- affinity - 0.5 * max(affinity)
#q <- quantile(affinity, c(0.1,0.9))
#gamma <- log(M) / (q[2] - q[1])
#affinity<-affinity - 0.5*max(affinity)
#affinity <- exp(gamma * (affinity-0.5*max(affinity)))
#affinity <- exp(gamma * affinity)
# Spectral Clustering of the coding vectors
# Normalized Laplacian matrix
D_inv_sqrt <- 1 / sqrt(rowSums(affinity))
L <- diag(n_nodes) - t(affinity * D_inv_sqrt) * D_inv_sqrt
eigen.res<-eigen(-L, symmetric = TRUE)
ifelse(is.null(n_classes),
n_classes <- kneedle(x=1:length(eigen.res$values),y=eigen.res$values)[1]-1,
n_classes <-n_classes)
print(elbow(eigen.res$values))
plot(eigen.res$values)
eigvecs <- eigen.res$vectors[,1:n_classes]
eigvecs <- eigvecs / sqrt(rowSums(eigvecs ^ 2))
labels <-
kmeans(eigvecs, nstart = 20, centers = n_classes)$cluster
# Contaminate
clusters <- labels[kmeans_labels]
return(list(clusters = clusters, centers = kmeans_centers))
}
plot_spectral_bridges<-function(X, centers, col_x=1, col_y=2, size_data = 1, size_centers = 3) {
# Convert matrices to data frames
df_X <- as.data.frame(X)
df_centers <- as.data.frame(centers)
# Create a ggplot
plot <- ggplot() +
geom_point(data = df_X, aes_string(x = names(df_X)[col_x], y = names(df_X)[col_y]), size = size_data, color = 'blue') +
geom_point(data = df_centers, aes_string(x = names(df_centers)[col_x], y = names(df_centers)[col_y]), size = size_centers, color = 'red') +
labs(x = names(df_X)[col_x], y = names(df_X)[col_y], title = paste("Plot of", names(df_X)[col_x], "vs", names(df_X)[col_y])) +
theme_minimal()
# Print the plot
print(plot)
}
K<-3
n<-100*2*K
delta=2
y<-rep(1:K,each=100)
X<-rbind(matrix(rnorm(n/K),n/K/2,2),matrix(rnorm(n/K),n/K/2,2)+delta,matrix(rnorm(n/K),n/K/2,2)+2*0)
res<-spectral_bridges(X,n_nodes=30,n_classes=NULL)
table(res$cluster,y)
#plot_spectral_bridges(X=iris,centers=res$centers)
plot(X)
K<-3
n<-100*2*K
delta=2
y<-rep(1:K,each=100)
X<-rbind(matrix(rnorm(n/K),n/K/2,2),matrix(rnorm(n/K),n/K/2,2)+delta,matrix(rnorm(n/K),n/K/2,2)+2*delta)
plot(X)
data("geyser")
help(geyser)
geyser
geyser
data(geyser)
X<-geyser
data(geyser)
X<-geyser
res<-spectral_bridges(X,n_nodes=12,n_classes=NULL)
res$clusters
data(geyser)
X<-scale(geyser,center = TRUE,scale=TRUE)
res<-spectral_bridges(X,n_nodes=12,n_classes=NULL)
res$clusters
plot(geyser,col=res$clusters)
setwd("~/Desktop/Spectral-Bridges")
library(clusterR)
install.packages("clusterR")
install.packages('ClusterR')
library(clsuterR)
library(ClusterR)
help("KMeans_rcpp")
kmeans_result  = KMeans_rcpp(X, clusters = n_nodes, num_init = 1, max_iters = 1, initializer = 'kmeans++')
X
K<-3
n<-100*2*K
delta=3
y<-rep(1:K,each=100)
X<-rbind(matrix(rnorm(n/K),n/K/2,2),matrix(rnorm(n/K),n/K/2,2)+delta,matrix(rnorm(n/K),n/K/2,2)+2*delta)
kmeans_result  = KMeans_rcpp(X, clusters = n_nodes, num_init = 1, max_iters = 1, initializer = 'kmeans++')
n_nodes<-30
kmeans_result  = KMeans_rcpp(X, clusters = n_nodes, num_init = 1, max_iters = 1, initializer = 'kmeans++')
str(kmeans_result)
table(kmeans(X,3)$cluster,iris$Species
)
table(kmeans(X,3)$cluster,iris$Species)
table(kmeans(iris[,1:4],3)$cluster,iris$Species)
quantile(affinity,0.1,0.9)
diff(c(1,3))
n <- nrow(X)
# kmeans_result <-
#   kmeans(
#     X,
#     centers = n_nodes,
#     algorithm = "Lloyd",
#     iter.max = 1 ,nstart=10
#   )
# kmeans_centers <- kmeans_result$centers
# kmeans_labels <-  kmeans_result$cluster
# kmeans_size <-  kmeans_result$size
#
kmeans_result  = KMeans_rcpp(X, clusters = n_nodes, num_init = 1, max_iters = 10, initializer = 'kmeans++')
kmeans_centers <- kmeans_result$centroids
kmeans_labels <-  kmeans_result$clusters
kmeans_size <-  kmeans_result$obs_per_cluster
# Similarity computation
affinity <- matrix(0, n_nodes, n_nodes)
X.centered <-
do.call(rbind, lapply(1:n, function(i) {
X[i, ] - kmeans_centers[kmeans_labels[i], ]
}))
affinity <- outer(1:n_nodes, 1:n_nodes,
Vectorize(function(k, l) {
ifelse(k == l,
0,
(sum(pmax(
0, (kmeans_centers[l,] - kmeans_centers[k, ]) %*% t(X.centered[(kmeans_labels ==
k), ])
)) +
sum(pmax(
0, (kmeans_centers[k,] - kmeans_centers[l, ]) %*% t(X.centered[(kmeans_labels ==
l), ])
))) /
(sum((kmeans_centers[k,] - kmeans_centers[l, ]) ^
2
) * (kmeans_size[k] + kmeans_size[l])))
}))
gamma<- log(1.e3)/diff(quantile(affinity,0.1,0.9))
affinity<- exp(gamma*(affinity - 0.5*max(affinity)))
str(affinity)
affinity
log(1e3)
n <- nrow(X)
# kmeans_result <-
#   kmeans(
#     X,
#     centers = n_nodes,
#     algorithm = "Lloyd",
#     iter.max = 1 ,nstart=10
#   )
# kmeans_centers <- kmeans_result$centers
# kmeans_labels <-  kmeans_result$cluster
# kmeans_size <-  kmeans_result$size
#
kmeans_result  = KMeans_rcpp(X, clusters = n_nodes, num_init = 1, max_iters = 10, initializer = 'kmeans++')
kmeans_centers <- kmeans_result$centroids
kmeans_labels <-  kmeans_result$clusters
kmeans_size <-  kmeans_result$obs_per_cluster
# Similarity computation
affinity <- matrix(0, n_nodes, n_nodes)
X.centered <-
do.call(rbind, lapply(1:n, function(i) {
X[i, ] - kmeans_centers[kmeans_labels[i], ]
}))
affinity <- outer(1:n_nodes, 1:n_nodes,
Vectorize(function(k, l) {
ifelse(k == l,
0,
(sum(pmax(
0, (kmeans_centers[l,] - kmeans_centers[k, ]) %*% t(X.centered[(kmeans_labels ==
k), ])
)) +
sum(pmax(
0, (kmeans_centers[k,] - kmeans_centers[l, ]) %*% t(X.centered[(kmeans_labels ==
l), ])
))) /
(sum((kmeans_centers[k,] - kmeans_centers[l, ]) ^
2
) * (kmeans_size[k] + kmeans_size[l])))
}))
gamma<- log(1.e3)/diff(quantile(affinity,0.1,0.9))
affinity<- exp(gamma*(affinity - 0.5*max(affinity)))
n <- nrow(X)
# kmeans_result <-
#   kmeans(
#     X,
#     centers = n_nodes,
#     algorithm = "Lloyd",
#     iter.max = 1 ,nstart=10
#   )
# kmeans_centers <- kmeans_result$centers
# kmeans_labels <-  kmeans_result$cluster
# kmeans_size <-  kmeans_result$size
#
kmeans_result  = KMeans_rcpp(X, clusters = n_nodes, num_init = 1, max_iters = 10, initializer = 'kmeans++')
kmeans_centers <- kmeans_result$centroids
kmeans_labels <-  kmeans_result$clusters
kmeans_size <-  kmeans_result$obs_per_cluster
# Similarity computation
affinity <- matrix(0, n_nodes, n_nodes)
X.centered <-
do.call(rbind, lapply(1:n, function(i) {
X[i, ] - kmeans_centers[kmeans_labels[i], ]
}))
affinity <- outer(1:n_nodes, 1:n_nodes,
Vectorize(function(k, l) {
ifelse(k == l,
0,
(sum(pmax(
0, (kmeans_centers[l,] - kmeans_centers[k, ]) %*% t(X.centered[(kmeans_labels ==
k), ])
)) +
sum(pmax(
0, (kmeans_centers[k,] - kmeans_centers[l, ]) %*% t(X.centered[(kmeans_labels ==
l), ])
))) /
(sum((kmeans_centers[k,] - kmeans_centers[l, ]) ^
2
) * (kmeans_size[k] + kmeans_size[l])))
}))
str(affinity)
gamma<- log(1e3)/diff(quantile(affinity,0.1,0.9))
gamma
quantile(affinity,0.1,0.9)
quantile(affinity,c(0.1,0.9))
fviz_cluster(kmeans_result, data = data, geom = "point", stand = FALSE)
library(factoextra)
fviz_cluster(kmeans_result, data = data, geom = "point", stand = FALSE)
n_nodes=25
n_classes=3
res<-spectral_bridges(X,n_nodes=n_nodes,n_classes=n_classes)
spectral_bridges <-  function(X,
n_classes = NULL,
n_nodes = 30,
M = 1e3) {
#  Vector quantization
n <- nrow(X)
# kmeans_result <-
#   kmeans(
#     X,
#     centers = n_nodes,
#     algorithm = "Lloyd",
#     iter.max = 1 ,nstart=10
#   )
# kmeans_centers <- kmeans_result$centers
# kmeans_labels <-  kmeans_result$cluster
# kmeans_size <-  kmeans_result$size
#
kmeans_result  = KMeans_rcpp(X, clusters = n_nodes, num_init = 1, max_iters = 1, initializer = 'kmeans++')
kmeans_centers <- kmeans_result$centroids
kmeans_labels <-  kmeans_result$clusters
kmeans_size <-  kmeans_result$obs_per_cluster
# Similarity computation
affinity <- matrix(0, n_nodes, n_nodes)
X.centered <-
do.call(rbind, lapply(1:n, function(i) {
X[i, ] - kmeans_centers[kmeans_labels[i], ]
}))
affinity <- outer(1:n_nodes, 1:n_nodes,
Vectorize(function(k, l) {
ifelse(k == l,
0,
(sum(pmax(
0, (kmeans_centers[l,] - kmeans_centers[k, ]) %*% t(X.centered[(kmeans_labels ==
k), ])
)) +
sum(pmax(
0, (kmeans_centers[k,] - kmeans_centers[l, ]) %*% t(X.centered[(kmeans_labels ==
l), ])
))) /
(sum((kmeans_centers[k,] - kmeans_centers[l, ]) ^
2
) * (kmeans_size[k] + kmeans_size[l])))
}))
#gamma<- log(1e3)/diff(quantile(affinity,c(0.1,0.9)))
#affinity<- exp(gamma*(affinity - 0.5*max(affinity)))
# Spectral Clustering of the coding vectors
# Normalized Laplacian matrix
D_inv_sqrt <- 1 / sqrt(rowSums(affinity))
L <- diag(n_nodes) - t(affinity * D_inv_sqrt) * D_inv_sqrt
eigen.res<-eigen(-L, symmetric = TRUE)
ifelse(is.null(n_classes),
n_classes <- kneedle(x=1:length(eigen.res$values),y=eigen.res$values)[1]-1,
n_classes <-n_classes)
print(elbow(eigen.res$values))
plot(eigen.res$values)
eigvecs <- eigen.res$vectors[,1:n_classes]
eigvecs <- eigvecs / sqrt(rowSums(eigvecs ^ 2))
labels <-
kmeans(eigvecs, nstart = 20, centers = n_classes)$cluster
# Contaminate
clusters <- labels[kmeans_labels]
return(list(clusters = clusters, centers = kmeans_centers))
}
n_nodes=25
n_classes=3
res<-spectral_bridges(X,n_nodes=n_nodes,n_classes=n_classes)
knitr::opts_chunk$set(echo = TRUE)
spectral_bridges <-  function(X,
n_classes = NULL,
n_nodes = 30,
M = 1e3) {
#  Vector quantization
n <- nrow(X)
# kmeans_result <-
#   kmeans(
#     X,
#     centers = n_nodes,
#     algorithm = "Lloyd",
#     iter.max = 1 ,nstart=10
#   )
# kmeans_centers <- kmeans_result$centers
# kmeans_labels <-  kmeans_result$cluster
# kmeans_size <-  kmeans_result$size
#
kmeans_result  = KMeans_rcpp(X, clusters = n_nodes, num_init = 1, max_iters = 1, initializer = 'kmeans++')
kmeans_centers <- kmeans_result$centroids
kmeans_labels <-  kmeans_result$clusters
kmeans_size <-  kmeans_result$obs_per_cluster
# Similarity computation
affinity <- matrix(0, n_nodes, n_nodes)
X.centered <-
do.call(rbind, lapply(1:n, function(i) {
X[i, ] - kmeans_centers[kmeans_labels[i], ]
}))
affinity <- outer(1:n_nodes, 1:n_nodes,
Vectorize(function(k, l) {
ifelse(k == l,
0,
(sum(pmax(
0, (kmeans_centers[l,] - kmeans_centers[k, ]) %*% t(X.centered[(kmeans_labels ==
k), ])
)) +
sum(pmax(
0, (kmeans_centers[k,] - kmeans_centers[l, ]) %*% t(X.centered[(kmeans_labels ==
l), ])
))) /
(sum((kmeans_centers[k,] - kmeans_centers[l, ]) ^
2
) * (kmeans_size[k] + kmeans_size[l])))
}))
#gamma<- log(1e3)/diff(quantile(affinity,c(0.1,0.9)))
#affinity<- exp(gamma*(affinity - 0.5*max(affinity)))
# Spectral Clustering of the coding vectors
# Normalized Laplacian matrix
D_inv_sqrt <- 1 / sqrt(rowSums(affinity))
L <- diag(n_nodes) - t(affinity * D_inv_sqrt) * D_inv_sqrt
eigen.res<-eigen(-L, symmetric = TRUE)
ifelse(is.null(n_classes),
n_classes <- kneedle(x=1:length(eigen.res$values),y=eigen.res$values)[1]-1,
n_classes <-n_classes)
plot(eigen.res$values)
eigvecs <- eigen.res$vectors[,1:n_classes]
eigvecs <- eigvecs / sqrt(rowSums(eigvecs ^ 2))
labels <-
kmeans(eigvecs, nstart = 20, centers = n_classes)$cluster
# Contaminate
clusters <- labels[kmeans_labels]
return(list(clusters = clusters, centers = kmeans_centers))
}
n_nodes=25
n_classes=3
res<-spectral_bridges(X,n_nodes=n_nodes,n_classes=n_classes)
kmeans_result  = KMeans_rcpp(X, clusters = n_nodes, num_init = 1, max_iters = 1, initializer = 'kmeans++')
fviz_cluster(kmeans_result, data = X, geom = "point", stand = FALSE)
kmeans_result  = kmeans(X, centers = n_nodes,iter.max = 1)
fviz_cluster(kmeans_result, data = X, geom = "point", stand = FALSE)
kmeans_result  = kmeans(X, centers = n_nodes,iter.max = 10)
fviz_cluster(kmeans_result, data = X, geom = "point", stand = FALSE)
library(factoextra)
library(cluster)
# Example data
set.seed(42)
data <- matrix(rnorm(10000), ncol = 2)
# Perform K-means with K-means++ initialization
kmeans_result <- kmeans(data, centers = 256, nstart = 10, algorithm = "Lloyd")
# Visualize the result
fviz_cluster(kmeans_result, data = data, geom = "point", stand = FALSE)
kmeans_result  = kmeans(X, centers = n_nodes,iter.max = 10)
fviz_cluster(kmeans_result, data = X,
palette = c("#2E9FDF", "#00AFBB", "#E7B800"),
geom = "point",
ellipse.type = "convex",
ggtheme = theme_bw()
)
help("fviz_cluster")
fviz_cluster(kmeans_result, data = X,
palette = c("#2E9FDF", "#00AFBB", "#E7B800"),
geom = "point",
ellipse.type = "convex",
ggtheme = theme_bw()
)
str(X)
fviz_cluster(kmeans_result, data = data.frame(X),
palette = c("#2E9FDF", "#00AFBB", "#E7B800"),
geom = "point",
ellipse.type = "convex",
ggtheme = theme_bw()
)
kmeans_result  = kmeans(X, centers = n_nodes,iter.max = 10)
fviz_cluster(kmeans_result, data = data.frame(X),
palette = c("#2E9FDF", "#00AFBB", "#E7B800"),
geom = "point",
ellipse.type = "convex",
ggtheme = theme_bw()
)
kmeans_result  = kmeans(X, centers = n_nodes,iter.max = 10)
fviz_cluster(kmeans_result, data = data.frame(X),
geom = "point",
ellipse.type = "convex",
ggtheme = theme_bw()
)
help("fviz_cluster")
kmeans_result  = kmeans(X, centers = n_nodes,iter.max = 10)
fviz_cluster(kmeans_result, data = data.frame(X),
geom = "point",
ellipse.type = "norm",
ggtheme = theme_bw()
)
help("fviz_cluster")
kmeans_result  = kmeans(X, centers = n_nodes,iter.max = 10)
fviz_cluster(kmeans_result, data = data.frame(X),
geom = "point",
ellipse.type = "euclid",
ggtheme = theme_bw()
)
fviz_cluster(kmeans_result, data = data.frame(X),
geom = "point",
ellipse.type = "t",
ggtheme = theme_bw()
)
kmeans_result  = kmeans(X, centers = n_nodes,iter.max = 10)
fviz_cluster(kmeans_result, data = data.frame(X),
geom = "point",
ellipse.type = "convex",
ggtheme = theme_bw()
)
n_nodes=10
n_classes=3
res<-spectral_bridges(X,n_nodes=n_nodes,n_classes=n_classes)
kmeans_result  = kmeans(X, centers = n_nodes,iter.max = 10)
fviz_cluster(kmeans_result, data = data.frame(X),
geom = "point",
ellipse.type = "convex",
ggtheme = theme_bw()
)
X<-iris[,1:4]
y<-iris$Species
n_nodes=10
n_classes=3
res<-spectral_bridges(X,n_nodes=n_nodes,n_classes=n_classes)
#kmeans_result  = kmeans(X, centers = n_nodes,iter.max = 10)
#fviz_cluster(kmeans_result, data = data.frame(X),
#             geom = "point",
#             ellipse.type = "convex",
#             ggtheme = theme_bw()
#             )
table(res$cluster,y)
help("fviz_cluster")
help("partition")
install.packages("keras")
install.packages("keras")
library(keras)
mnist <- dataset_mnist()
mnist<-dataset_mnist()
library(keras)
mnist<-dataset_mnist()
install.packages("reticulate")
install.packages("reticulate")
library(reticulate)
use_python("/Users/cambroise/miniconda3/bin/python")
library(tensorflow)
library(keras)
mnist<-dataset_mnist()
install_tensorflow(method = "conda")
library(keras)
mnist<-dataset_mnist()
install_tensorflow()
library(keras)
mnist<-dataset_mnist()
devtools::install_github("jlmelville/mnist")
library(mnist)
ls()
data(mnist)
library(help=mnist)
help(download_mnist)
mnist <- download_mnist()
library(keras)
data(mnist)
dataset_mnist()
install_tensorflow()

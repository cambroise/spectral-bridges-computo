X[i, ] - kmeans_centers[kmeans_labels[i], ]
})))
affinity <- outer(1:n_nodes, 1:n_nodes, Vectorize(function(k, l) {
if (k == l) 0 else {
distkl2 <- sum(((kmeans_centers[l, ] - kmeans_centers[k, ]))^2)
alphai <- c(pmax(0, (kmeans_centers[l, ] - kmeans_centers[k, ]) %*%
t(X.centered[(kmeans_labels == k), ])) / distkl2,
(pmax(0, (kmeans_centers[k, ] - kmeans_centers[l, ]) %*%
t(X.centered[(kmeans_labels == l), ])) / distkl2))
sqrt(sum(alphai^2) / (kmeans_size[k] + kmeans_size[l]))
}
}))
affinity.old <- affinity
affinity[affinity < 0.1] <- 0
transform <- "exp"
M <- 1e3
if (transform == "exp") {
gamma <- log(M) / diff(quantile(affinity.old, c(0.1, 0.9)))
affinity.old <- exp(gamma * (affinity.old - 0.5 * max(affinity.old)))
}
# Normalized Laplacian matrix
D_inv_sqrt <- 1 / sqrt(rowSums(affinity.old))
L <- diag(n_nodes) - t(affinity.old * D_inv_sqrt) * D_inv_sqrt
eigen.res <- eigen(-L, symmetric = TRUE)
# Determining the number of clusters
n_classes <- 3  # set to 3 or use a method to determine this dynamically
eigvecs <- eigen.res$vectors[, 1:n_classes]
eigvecs <- eigvecs / sqrt(rowSums(eigvecs ^ 2))
labels <- kmeans(eigvecs, nstart = 20, centers = n_classes)$cluster
# Assign labels to data points
clusters <- labels[kmeans_labels]
# Get the cluster centroids
centroids <- as.data.frame(kmeans_result$centroids)
colnames(centroids) <- c("PC1", "PC2")
centroids$label <- as.factor(labels)
# Compute Voronoi cells
voronoi <- deldir(centroids$PC1, centroids$PC2)
# Extract Voronoi edges
voronoi_edges <- voronoi$dirsgs
# Convert edges to a data frame for ggplot2
voronoi_edges_df <- as.data.frame(voronoi_edges)
# Extract Voronoi tiles
tiles <- tile.list(voronoi)
# Convert Voronoi tiles to a data frame for ggplot2
voronoi_df <- do.call(rbind, lapply(1:length(tiles), function(i) {
tile <- tiles[[i]]
data.frame(x = tile$x, y = tile$y, id = i)
}))
palette <- scales::hue_pal()(n_nodes)
# Add cluster labels to the Voronoi data frame
# Plot the first two PCA components with Voronoi cells colored by labels
ggplot() +
geom_point(data = X, aes(x = PC1, y = PC2, color = as.factor(clusters), alpha = 0.4)) +
geom_polygon(data = voronoi_df, aes(x = x, y = y, group = id,fill=as.factor(labels[id])), color = "black", alpha = 0.2) +
geom_point(data = centroids, aes(x = PC1, y = PC2), color = as.factor(labels), size = 5) +
theme_minimal() +
theme(
panel.grid = element_blank(),
legend.position = "none",
axis.title = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.line = element_blank()
)
# Load necessary libraries
library(ggplot2)
library(ClusterR)
library(deldir)  # for computing Voronoi cells
library(ggforce) # for drawing the Voronoi cells
# Load the iris dataset
data(iris)
# Perform PCA on the iris dataset
pca <- prcomp(iris[, 1:4], scale. = TRUE)
pca_data <- as.data.frame(pca$x)
X <- pca_data[, 1:2]
colnames(X) <- c("PC1", "PC2")
# Use KMeans_rcpp to cluster the PCA-transformed data into 20 clusters
set.seed(123)  # for reproducibility
n_nodes <- 20
n <- nrow(X)
kmeans_result <- KMeans_rcpp(X, clusters = n_nodes, num_init = 3, max_iters = 30, initializer = 'kmeans++')
kmeans_centers <- as.matrix(kmeans_result$centroids)
kmeans_labels <- as.matrix(kmeans_result$clusters)
kmeans_size <- kmeans_result$obs_per_cluster
kmeans_Iw <- kmeans_result$WCSS_per_cluster
# Affinity computation
affinity <- matrix(0, n_nodes, n_nodes)
X.centered <- as.matrix(do.call(rbind, lapply(1:n, function(i) {
X[i, ] - kmeans_centers[kmeans_labels[i], ]
})))
affinity <- outer(1:n_nodes, 1:n_nodes, Vectorize(function(k, l) {
if (k == l) 0 else {
distkl2 <- sum(((kmeans_centers[l, ] - kmeans_centers[k, ]))^2)
alphai <- c(pmax(0, (kmeans_centers[l, ] - kmeans_centers[k, ]) %*%
t(X.centered[(kmeans_labels == k), ])) / distkl2,
(pmax(0, (kmeans_centers[k, ] - kmeans_centers[l, ]) %*%
t(X.centered[(kmeans_labels == l), ])) / distkl2))
sqrt(sum(alphai^2) / (kmeans_size[k] + kmeans_size[l]))
}
}))
affinity.old <- affinity
affinity[affinity < 0.1] <- 0
transform <- "exp"
M <- 1e3
if (transform == "exp") {
gamma <- log(M) / diff(quantile(affinity.old, c(0.1, 0.9)))
affinity.old <- exp(gamma * (affinity.old - 0.5 * max(affinity.old)))
}
# Normalized Laplacian matrix
D_inv_sqrt <- 1 / sqrt(rowSums(affinity.old))
L <- diag(n_nodes) - t(affinity.old * D_inv_sqrt) * D_inv_sqrt
eigen.res <- eigen(-L, symmetric = TRUE)
# Determining the number of clusters
n_classes <- 3  # set to 3 or use a method to determine this dynamically
eigvecs <- eigen.res$vectors[, 1:n_classes]
eigvecs <- eigvecs / sqrt(rowSums(eigvecs ^ 2))
labels <- kmeans(eigvecs, nstart = 20, centers = n_classes)$cluster
# Assign labels to data points
clusters <- labels[kmeans_labels]
# Get the cluster centroids
centroids <- as.data.frame(kmeans_result$centroids)
colnames(centroids) <- c("PC1", "PC2")
centroids$label <- as.factor(labels)
# Compute Voronoi cells
voronoi <- deldir(centroids$PC1, centroids$PC2)
# Extract Voronoi edges
voronoi_edges <- voronoi$dirsgs
# Convert edges to a data frame for ggplot2
voronoi_edges_df <- as.data.frame(voronoi_edges)
# Extract Voronoi tiles
tiles <- tile.list(voronoi)
# Convert Voronoi tiles to a data frame for ggplot2
voronoi_df <- do.call(rbind, lapply(1:length(tiles), function(i) {
tile <- tiles[[i]]
data.frame(x = tile$x, y = tile$y, id = i)
}))
palette <- scales::hue_pal()(n_nodes)
# Add cluster labels to the Voronoi data frame
# Plot the first two PCA components with Voronoi cells colored by labels
ggplot() +
geom_point(data = X, aes(x = PC1, y = PC2, color = as.factor(clusters), alpha = 0.4)) +
geom_polygon(data = voronoi_df, aes(x = x, y = y, group = id,fill=as.factor(labels[id])), color = "black", alpha = 0.2) +
geom_point(data = centroids, aes(x = PC1, y = PC2), color = as.factor(labels+1), size = 5) +
theme_minimal() +
theme(
panel.grid = element_blank(),
legend.position = "none",
axis.title = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.line = element_blank()
)
# Load necessary libraries
library(ggplot2)
library(ClusterR)
library(deldir)  # for computing Voronoi cells
library(ggforce) # for drawing the Voronoi cells
# Load the iris dataset
data(iris)
# Perform PCA on the iris dataset
pca <- prcomp(iris[, 1:4], scale. = TRUE)
pca_data <- as.data.frame(pca$x)
X <- pca_data[, 1:2]
colnames(X) <- c("PC1", "PC2")
# Use KMeans_rcpp to cluster the PCA-transformed data into 20 clusters
set.seed(123)  # for reproducibility
n_nodes <- 20
n <- nrow(X)
kmeans_result <- KMeans_rcpp(X, clusters = n_nodes, num_init = 3, max_iters = 30, initializer = 'kmeans++')
kmeans_centers <- as.matrix(kmeans_result$centroids)
kmeans_labels <- as.matrix(kmeans_result$clusters)
kmeans_size <- kmeans_result$obs_per_cluster
kmeans_Iw <- kmeans_result$WCSS_per_cluster
# Affinity computation
affinity <- matrix(0, n_nodes, n_nodes)
X.centered <- as.matrix(do.call(rbind, lapply(1:n, function(i) {
X[i, ] - kmeans_centers[kmeans_labels[i], ]
})))
affinity <- outer(1:n_nodes, 1:n_nodes, Vectorize(function(k, l) {
if (k == l) 0 else {
distkl2 <- sum(((kmeans_centers[l, ] - kmeans_centers[k, ]))^2)
alphai <- c(pmax(0, (kmeans_centers[l, ] - kmeans_centers[k, ]) %*%
t(X.centered[(kmeans_labels == k), ])) / distkl2,
(pmax(0, (kmeans_centers[k, ] - kmeans_centers[l, ]) %*%
t(X.centered[(kmeans_labels == l), ])) / distkl2))
sqrt(sum(alphai^2) / (kmeans_size[k] + kmeans_size[l]))
}
}))
affinity.old <- affinity
affinity[affinity < 0.1] <- 0
transform <- "exp"
M <- 1e3
if (transform == "exp") {
gamma <- log(M) / diff(quantile(affinity.old, c(0.1, 0.9)))
affinity.old <- exp(gamma * (affinity.old - 0.5 * max(affinity.old)))
}
# Normalized Laplacian matrix
D_inv_sqrt <- 1 / sqrt(rowSums(affinity.old))
L <- diag(n_nodes) - t(affinity.old * D_inv_sqrt) * D_inv_sqrt
eigen.res <- eigen(-L, symmetric = TRUE)
# Determining the number of clusters
n_classes <- 3  # set to 3 or use a method to determine this dynamically
eigvecs <- eigen.res$vectors[, 1:n_classes]
eigvecs <- eigvecs / sqrt(rowSums(eigvecs ^ 2))
labels <- kmeans(eigvecs, nstart = 20, centers = n_classes)$cluster
# Assign labels to data points
clusters <- labels[kmeans_labels]
# Get the cluster centroids
centroids <- as.data.frame(kmeans_result$centroids)
colnames(centroids) <- c("PC1", "PC2")
centroids$label <- as.factor(labels)
# Compute Voronoi cells
voronoi <- deldir(centroids$PC1, centroids$PC2)
# Extract Voronoi edges
voronoi_edges <- voronoi$dirsgs
# Convert edges to a data frame for ggplot2
voronoi_edges_df <- as.data.frame(voronoi_edges)
# Extract Voronoi tiles
tiles <- tile.list(voronoi)
# Convert Voronoi tiles to a data frame for ggplot2
voronoi_df <- do.call(rbind, lapply(1:length(tiles), function(i) {
tile <- tiles[[i]]
data.frame(x = tile$x, y = tile$y, id = i)
}))
# Add cluster labels to the Voronoi data frame
palette <- scales::hue_pal()(n_nodes)
# Plot the first two PCA components with Voronoi cells colored by labels
p<-ggplot() +
geom_point(data = X, aes(x = PC1, y = PC2, color = as.factor(clusters), alpha = 0.4)) +
geom_polygon(data = voronoi_df, aes(x = x, y = y, group = id,fill=as.factor(labels[id])), color = "black", alpha = 0.2) +
geom_point(data = centroids, aes(x = PC1, y = PC2), color = as.factor(labels+1), size = 5) +
theme_minimal() +
theme(
panel.grid = element_blank(),
legend.position = "none",
axis.title = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.line = element_blank()
)
print(p)
# Load necessary libraries
library(ggplot2)
library(ClusterR)
library(deldir)  # for computing Voronoi cells
library(ggforce) # for drawing the Voronoi cells
# Load the iris dataset
data(iris)
# Perform PCA on the iris dataset
pca <- prcomp(iris[, 1:4], scale. = TRUE)
pca_data <- as.data.frame(pca$x)
X <- pca_data[, 1:2]
colnames(X) <- c("PC1", "PC2")
# Use KMeans_rcpp to cluster the PCA-transformed data into 20 clusters
set.seed(123)  # for reproducibility
n_nodes <- 20
n <- nrow(X)
kmeans_result <- KMeans_rcpp(X, clusters = n_nodes, num_init = 3, max_iters = 30, initializer = 'kmeans++')
kmeans_centers <- as.matrix(kmeans_result$centroids)
kmeans_labels <- as.matrix(kmeans_result$clusters)
kmeans_size <- kmeans_result$obs_per_cluster
kmeans_Iw <- kmeans_result$WCSS_per_cluster
# Affinity computation
affinity <- matrix(0, n_nodes, n_nodes)
X.centered <- as.matrix(do.call(rbind, lapply(1:n, function(i) {
X[i, ] - kmeans_centers[kmeans_labels[i], ]
})))
affinity <- outer(1:n_nodes, 1:n_nodes, Vectorize(function(k, l) {
if (k == l) 0 else {
distkl2 <- sum(((kmeans_centers[l, ] - kmeans_centers[k, ]))^2)
alphai <- c(pmax(0, (kmeans_centers[l, ] - kmeans_centers[k, ]) %*%
t(X.centered[(kmeans_labels == k), ])) / distkl2,
(pmax(0, (kmeans_centers[k, ] - kmeans_centers[l, ]) %*%
t(X.centered[(kmeans_labels == l), ])) / distkl2))
sqrt(sum(alphai^2) / (kmeans_size[k] + kmeans_size[l]))
}
}))
affinity.old <- affinity
affinity[affinity < 0.1] <- 0
transform <- "exp"
M <- 1e3
if (transform == "exp") {
gamma <- log(M) / diff(quantile(affinity.old, c(0.1, 0.9)))
affinity.old <- exp(gamma * (affinity.old - 0.5 * max(affinity.old)))
}
# Normalized Laplacian matrix
D_inv_sqrt <- 1 / sqrt(rowSums(affinity.old))
L <- diag(n_nodes) - t(affinity.old * D_inv_sqrt) * D_inv_sqrt
eigen.res <- eigen(-L, symmetric = TRUE)
# Determining the number of clusters
n_classes <- 3  # set to 3 or use a method to determine this dynamically
eigvecs <- eigen.res$vectors[, 1:n_classes]
eigvecs <- eigvecs / sqrt(rowSums(eigvecs ^ 2))
labels <- kmeans(eigvecs, nstart = 20, centers = n_classes)$cluster
# Assign labels to data points
clusters <- labels[kmeans_labels]
# Get the cluster centroids
centroids <- as.data.frame(kmeans_result$centroids)
colnames(centroids) <- c("PC1", "PC2")
centroids$label <- as.factor(labels)
# Compute Voronoi cells
voronoi <- deldir(centroids$PC1, centroids$PC2)
# Extract Voronoi edges
voronoi_edges <- voronoi$dirsgs
# Convert edges to a data frame for ggplot2
voronoi_edges_df <- as.data.frame(voronoi_edges)
# Extract Voronoi tiles
tiles <- tile.list(voronoi)
# Convert Voronoi tiles to a data frame for ggplot2
voronoi_df <- do.call(rbind, lapply(1:length(tiles), function(i) {
tile <- tiles[[i]]
data.frame(x = tile$x, y = tile$y, id = i)
}))
# Add cluster labels to the Voronoi data frame
palette <- scales::hue_pal()(n_nodes)
# Plot the first two PCA components with Voronoi cells colored by labels
p<-ggplot() +
geom_point(data = X, aes(x = PC1, y = PC2, color = as.factor(clusters), alpha = 0.4)) +
geom_polygon(data = voronoi_df, aes(x = x, y = y, group = id,fill=as.factor(labels[id])), color = "black", alpha = 0.2) +
geom_point(data = centroids, aes(x = PC1, y = PC2), color = as.factor(labels+1), size = 5) +
theme_minimal() +
theme(
panel.grid = element_blank(),
legend.position = "none",
axis.title = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.line = element_blank()
)
pdf("spectral-briges-3-4.pdf")
print(p)
dev.off()
# Load necessary libraries
library(ggplot2)
library(ClusterR)
library(deldir)  # for computing Voronoi cells
library(ggforce) # for drawing the Voronoi cells
# Load the iris dataset
data(iris)
# Perform PCA on the iris dataset
pca <- prcomp(iris[, 1:4], scale. = TRUE)
pca_data <- as.data.frame(pca$x)
X <- pca_data[, 1:2]
colnames(X) <- c("PC1", "PC2")
# Use KMeans_rcpp to cluster the PCA-transformed data into 20 clusters
set.seed(123)  # for reproducibility
n_nodes <- 20
n <- nrow(X)
kmeans_result <- KMeans_rcpp(X, clusters = n_nodes, num_init = 3, max_iters = 30, initializer = 'kmeans++')
kmeans_centers <- as.matrix(kmeans_result$centroids)
kmeans_labels <- as.matrix(kmeans_result$clusters)
kmeans_size <- kmeans_result$obs_per_cluster
kmeans_Iw <- kmeans_result$WCSS_per_cluster
# Affinity computation
affinity <- matrix(0, n_nodes, n_nodes)
X.centered <- as.matrix(do.call(rbind, lapply(1:n, function(i) {
X[i, ] - kmeans_centers[kmeans_labels[i], ]
})))
affinity <- outer(1:n_nodes, 1:n_nodes, Vectorize(function(k, l) {
if (k == l) 0 else {
distkl2 <- sum(((kmeans_centers[l, ] - kmeans_centers[k, ]))^2)
alphai <- c(pmax(0, (kmeans_centers[l, ] - kmeans_centers[k, ]) %*%
t(X.centered[(kmeans_labels == k), ])) / distkl2,
(pmax(0, (kmeans_centers[k, ] - kmeans_centers[l, ]) %*%
t(X.centered[(kmeans_labels == l), ])) / distkl2))
sqrt(sum(alphai^2) / (kmeans_size[k] + kmeans_size[l]))
}
}))
affinity.old<-affinity
affinity[affinity<0.1]<-0
transform<-"exp"
M<-1e3
if (transform=="exp"){
gamma<- log(M)/diff(quantile(affinity.old,c(0.1,0.9)))
affinity.old<- exp(gamma*(affinity.old - 0.5*max(affinity.old)))}
# 3. Spectral Clustering of the coding vectors
###################################
# Normalized Laplacian matrix
D_inv_sqrt <- 1 / sqrt(rowSums(affinity.old))
L <- diag(n_nodes) - t(affinity.old * D_inv_sqrt) * D_inv_sqrt
eigen.res<-eigen(-L, symmetric = TRUE)
#eigen.res<-eigs_sym(-L, n_classes)
ifelse(is.null(n_classes),
n_classes <- kneedle(x=1:length(eigen.res$values),y=eigen.res$values)[1]-1,
n_classes <-n_classes)
plot(eigen.res$values)
eigvecs <- eigen.res$vectors[,1:n_classes]
eigvecs <- eigvecs / sqrt(rowSums(eigvecs ^ 2))
labels <-
kmeans(eigvecs, nstart = 20, centers = n_classes)$cluster
# 4. Contaminate
###################################
clusters <- labels[kmeans_labels]
# Get the cluster centroids
centroids <- as.data.frame(kmeans_result$centroids)
colnames(centroids) <- c("PC1", "PC2")
# Compute Voronoi cells
voronoi <- deldir(centroids$PC1, centroids$PC2)
# Extract Voronoi edges
voronoi_edges <- voronoi$dirsgs
# Convert edges to a data frame for ggplot2
voronoi_edges_df <- as.data.frame(voronoi_edges)
# Create data frame for affinity lines
affinity_lines <- data.frame(
x = rep(centroids$PC1, each = n_nodes),
y = rep(centroids$PC2, each = n_nodes),
xend = rep(centroids$PC1, times = n_nodes),
yend = rep(centroids$PC2, times = n_nodes),
weight = as.vector(affinity)
)
# Filter out self-loops and zero affinities
affinity_lines <- subset(affinity_lines, weight > 0)
# Plot the first two PCA components with Voronoi cells and affinity lines
p<-ggplot() +
geom_point(data = X, aes(x = PC1, y = PC2, color = as.factor(kmeans_result$clusters), alpha = 0.4)) +
geom_polygon(data = voronoi_df, aes(x = x, y = y, group = id), color = "black", alpha = 0.2,fill="white") +
geom_segment(data = affinity_lines, aes(x = x, y = y, xend = xend, yend = yend, size = weight), color = "blue") +
geom_point(data = centroids, aes(x = PC1, y = PC2), color = "red", size = 5) +
scale_size_continuous(range = c(0.5, 2)) +  # Adjust the size range as needed
theme_minimal() +
theme(
panel.grid = element_blank(),
legend.position = "none",
axis.title = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.line = element_blank()
)
pdf("spectral-briges-2.pdf")
print(p)
dev.off()
# Load necessary libraries
library(ggplot2)
library(ClusterR)
library(deldir)  # for computing Voronoi cells
library(ggforce) # for drawing the Voronoi cells
# Load the iris dataset
data(iris)
# Perform PCA on the iris dataset
pca <- prcomp(iris[, 1:4], scale. = TRUE)
pca_data <- as.data.frame(pca$x)
X<-pca_data[, 1:2]
# Use KMeans_rcpp to cluster the PCA-transformed data into 20 clusters
set.seed(123)  # for reproducibility
n_nodes=20
n<-nrow(X)
kmeans_result  = KMeans_rcpp(X, clusters = n_nodes,
num_init = 3, max_iters =30,
initializer = 'kmeans++')
kmeans_centers <- as.matrix(kmeans_result$centroids)
kmeans_labels <-  as.matrix(kmeans_result$clusters)
kmeans_size <-    kmeans_result$obs_per_cluster
kmeans_Iw<-kmeans_result$WCSS_per_cluster
# 2. Affinity computation
###################################
affinity <- matrix(0, n_nodes, n_nodes)
X.centered <-
as.matrix(do.call(rbind, lapply(1:n, function(i) {
X[i, ] - kmeans_centers[kmeans_labels[i], ]
})))
affinity <- matrix(0, n_nodes, n_nodes)
X.centered <-
as.matrix(do.call(rbind, lapply(1:n, function(i) {
X[i, ] - kmeans_centers[kmeans_labels[i], ]
})))
affinity <- outer(1:n_nodes, 1:n_nodes,
Vectorize(function(k, l) {
if (k==l) 0 else {
distkl2<-sum(((kmeans_centers[l,] - kmeans_centers[k, ]))^2);
alphai<-c(pmax(0, (kmeans_centers[l,] - kmeans_centers[k, ]) %*%
t(X.centered[(kmeans_labels ==k), ]))/distkl2,
(pmax(0, (kmeans_centers[k,] - kmeans_centers[l, ]) %*%
t(X.centered[(kmeans_labels ==l), ]))/distkl2));
sqrt(sum(alphai^2)/(kmeans_size[k]+kmeans_size[l]))
#compute_entropy(ti)
}
}))
# Get the cluster centroids
centroids <- as.data.frame(kmeans_result$centroids)
colnames(centroids) <- c("PC1", "PC2")
# Compute Voronoi cells
voronoi <- deldir(centroids$PC1, centroids$PC2)
# Extract Voronoi edges
voronoi_edges <- voronoi$dirsgs
# Convert edges to a data frame for ggplot2
voronoi_edges_df <- as.data.frame(voronoi_edges)
# Plot the first two PCA components with Voronoi cells
p<-ggplot() +
geom_point(data = X, aes(x = PC1, y = PC2, color = as.factor(kmeans_result$clusters),alpha=0.4)) +
geom_polygon(data = voronoi_df, aes(x = x, y = y, group = id), color = "black", alpha = 0.2,fill="white") +
geom_point(data = centroids, aes(x = PC1, y = PC2), color = "red", size = 5) +
theme_minimal() +
theme(
panel.grid = element_blank(),
legend.position = "none",
axis.title = element_blank(),
axis.text = element_blank(),
axis.ticks = element_blank(),
axis.line = element_blank()
)
#+
#labs(title = "Voronoi Cells in the First PCA Plane of the Iris Dataset",
#     x = "PC1",
#     y = "PC2",
#     color = "Cluster")
pdf("spectral-briges-1.pdf")
print(p)
dev.off()
7/4000 * 365
7* 365
7* 50
7* 52

---
title: "Untitled"
author: "Christophe Ambroise"
date: "2024-06-13"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r}
library(ggplot2)
library(kneedle)


elbow<-function(x){
  which.max(diff(diff(x)))+1
}

spectral_bridges <-  function(X,
                              n_classes = NULL,
                              n_nodes = 30,
                              M = 1e3) {
  #  Vector quantification
  n <- nrow(X)
  kmeans_result <-
    kmeans(
      X,
      centers = n_nodes,
      algorithm = "Lloyd",
      iter.max = 1 ,nstart=10
    )
  kmeans_centers <- kmeans_result$centers
  kmeans_labels <-  kmeans_result$cluster
  kmeans_size <-  kmeans_result$size
  
  # Similarity computation
  affinity <- matrix(0, n_nodes, n_nodes)
  X.centered <-
    do.call(rbind, lapply(1:n, function(i) {
      X[i, ] - kmeans_centers[kmeans_labels[i], ]
    }))
  
  affinity <- outer(1:n_nodes, 1:n_nodes,
                    Vectorize(function(k, l) {
                      ifelse(k == l,
                             0,
                             (sum(pmax(
                               0, (kmeans_centers[l,] - kmeans_centers[k, ]) %*% t(X.centered[(kmeans_labels ==
                                                                                                 k), ])
                             )) +
                               sum(pmax(
                                 0, (kmeans_centers[k,] - kmeans_centers[l, ]) %*% t(X.centered[(kmeans_labels ==
                                                                                                   l), ])
                               ))) /
                               (sum((kmeans_centers[k,] - kmeans_centers[l, ]) ^
                                      2
                               ) * (kmeans_size[k] + kmeans_size[l])))
                    }))
  
  #affinity <- affinity - 0.5 * max(affinity)
  #q <- quantile(affinity, c(0.1,0.9))
  #gamma <- log(M) / (q[2] - q[1])
  #affinity<-affinity - 0.5*max(affinity)
  #affinity <- exp(gamma * (affinity-0.5*max(affinity)))
  #affinity <- exp(gamma * affinity)
  
  
  # Spectral Clustering of the coding vectors
  # Normalized Laplacian matrix
  D_inv_sqrt <- 1 / sqrt(rowSums(affinity))
  L <- diag(n_nodes) - t(affinity * D_inv_sqrt) * D_inv_sqrt
  eigen.res<-eigen(-L, symmetric = TRUE)
  ifelse(is.null(n_classes), 
         n_classes <- kneedle(x=1:length(eigen.res$values),y=eigen.res$values)[1]-1,
         n_classes <-n_classes)
  print(elbow(eigen.res$values))
  plot(eigen.res$values)
  eigvecs <- eigen.res$vectors[,1:n_classes]
  eigvecs <- eigvecs / sqrt(rowSums(eigvecs ^ 2))
  labels <-
    kmeans(eigvecs, nstart = 20, centers = n_classes)$cluster
  
  # Contaminate
  clusters <- labels[kmeans_labels]
  
  return(list(clusters = clusters, centers = kmeans_centers))
}


plot_spectral_bridges<-function(X, centers, col_x=1, col_y=2, size_data = 1, size_centers = 3) {
  # Convert matrices to data frames
  df_X <- as.data.frame(X)
  df_centers <- as.data.frame(centers)
  
  
  # Create a ggplot
 plot <- ggplot() +
  geom_point(data = df_X, aes_string(x = names(df_X)[col_x], y = names(df_X)[col_y]), size = size_data, color = 'blue') +
  geom_point(data = df_centers, aes_string(x = names(df_centers)[col_x], y = names(df_centers)[col_y]), size = size_centers, color = 'red') +
  labs(x = names(df_X)[col_x], y = names(df_X)[col_y], title = paste("Plot of", names(df_X)[col_x], "vs", names(df_X)[col_y])) +
  theme_minimal()
 
  # Print the plot
  print(plot)
}

K<-3
n<-100*2*K
delta=3
y<-rep(1:K,each=100)
X<-rbind(matrix(rnorm(n/K),n/K/2,2),matrix(rnorm(n/K),n/K/2,2)+delta,matrix(rnorm(n/K),n/K/2,2)+2*delta) 

res<-spectral_bridges(X,n_nodes=12,n_classes=NULL)
table(res$cluster,y)
#plot_spectral_bridges(X=iris,centers=res$centers)
```

